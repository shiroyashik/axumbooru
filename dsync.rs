use std::{collections::HashMap, path::PathBuf};
use dsync::{GenerationConfig, TableOptions};

pub fn main() {
    let dir = env!("CARGO_MANIFEST_DIR");

    println!("Running dsync (generating model code from `src/schema.rs`)");

    let schema_file = PathBuf::from_iter([dir, "src/schema.rs"]);
    let models_dir = PathBuf::from_iter([dir, "src/models"]);

    ensure_schema_is_generated(&schema_file);

    dsync::generate_files(
        schema_file, 
        models_dir, 
        GenerationConfig {
            connection_type: "bb8::Pool<AsyncDieselConnectionManager<AsyncPgConnection>>".to_string(),
            default_table_options: TableOptions::default().autogenerated_columns(vec![
                "created_at",
                "updated_at",
            ]),
            table_options: HashMap::from([
                // ("users", TableOptions::default()),
            ]),
            model_path: "crate::models::".to_string(),
            schema_path: "crate::schema::".to_string(),
        },
    );
}

pub fn ensure_schema_is_generated(schema_file: &PathBuf) {
    // check that the diesel schema file is not empty
    let content = std::fs::read_to_string(schema_file).unwrap_or_default();

    if content.trim().is_empty() {
        println!("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
        println!(" The diesel schema file is not generated yet.");
        println!(" If this is a new project, did you forget\n the `diesel database setup` step?");
        println!("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
        panic!("`backend/schema.rs` is empty or not present");
    }
}